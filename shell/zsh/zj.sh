#!/usr/bin/env zsh

# 设置了之后，不存在ZSHRC文件的时候会报错
#set -e # 如果脚本返回值不为0直接退出shell()

COLOR_RED='\033[0;31m' # COLOR_RED
ZSHRC="$HOME/.zshrc"
MARK_COMMENT='# Generated by shell job. DO NOT EDIT.'
MARK_START='# =========== [Dokiy] ============'
MARK_END='# ========= [Dokiy END] =========='

_locate() {
  echo "$(grep -Fxn "$1" "$ZSHRC" | awk -F: '{print $1}')"
}
_func_start() {
  start=$(_locate "function $1() {")

  loc_mark_start=$(_locate "$MARK_START")
  while true; do
    old_start=$start # 暂存比较

    # 向上查找，直到空白行或者首行
    if [[ (loc_mark_start -lt start) && (! -z $(sed -n "${start}p" "$ZSHRC")) ]]; then
      start=$((start - 1))
    fi

    # 如果没有变化则退出循环
    if [[ start -eq old_start ]]; then
      break
    fi
  done

  echo $((start + 1))
}
_func_end() {
  end=$(_locate "function $1() {")

  loc_mark_end=$(_locate "$MARK_END")
  while true; do
    old_end=$end # 暂存比较

    # 向下查找，直到空白行或者尾行
    if [[ (loc_mark_end -gt end) && (! -z $(sed -n "${end}p" "$ZSHRC")) ]]; then
      end=$((end + 1))
    fi

    # 如果没有变化则退出循环
    if [[ end -eq old_end ]]; then
      break
    fi
  done

  echo $((end - 1))
}
mark_content() {
  start=$(_locate "$MARK_START")
  end=$(_locate "$MARK_END")

  sed -n "${start},${end}p" "$ZSHRC"
}
func_names() {
  while read line; do
    echo $line | grep -E "^function.*() {$" | awk '{print $2}'
  done
}

# 初始化 .zshrc 配置文件
init() {
  # 检查是否存在
  find "$ZSHRC" >/dev/null 2>&1
  if [ $? -ne 0 ]; then
    touch "$ZSHRC"
  fi

  # 查找标记定位， 如果没找到则添加
  if [[ ! -z $(_locate "$MARK_END") ]]; then
    return
  fi

  echo "" >>"$ZSHRC"
  echo "$MARK_COMMENT" >>"$ZSHRC"
  echo "$MARK_START" >>"$ZSHRC"
  echo "" >>"$ZSHRC"
  echo "$MARK_END" >>"$ZSHRC"
}

# 获取所有方法列表
list() {
  mark_content | func_names
}

# 插入方法
insert() {
  local content="$1"

  # 文件中查找，以function的格式查找是否存在相同功能的方法名称
  insert_func_name=$(echo "$content" | func_names)
  is_exists_func=$(cat "$ZSHRC" | grep "$insert_func_name")
  # 存在同名方法，报错
  if [[ ! -z $is_exists_func ]]; then
    echo -e "${COLOR_RED}$0: $insert_func_name exists" 1>&2
    return
  fi

  # 获取待插入的标记定位，
  if [[ -z $(_locate "$MARK_END") ]]; then
    return
  fi
  loc=$(($(_locate "$MARK_END") - 1))

  # 不存在，分行写入
  local IFS='' # 使 read 保留空格
  echo "$content" | while read line; do
    sed -i '' "${loc}i\\
$line
" "$ZSHRC" # mac下的sed需要换行写
    loc=$((loc + 1))
  done
}

# 查看方法详情
detail() {
  sed -n "$(_func_start $1),$(_func_end $1)p" "$ZSHRC"
}

# 删除某个脚本
delete() {
  func_name=$1
  func_name=${func_name%\(*}   # 如果带括号则删除
  start=$(_func_start $func_name)
  end=$(_func_end $func_name)

  if [[ $start -le 0 || $end -le 0 ]]; then
    echo -e "${COLOR_RED}$0: $1 not found" 1>&2
    return
  fi
  sed -i '' "${start},${end}d" "$ZSHRC"
  # 删除方法开始的空白行
  sed -i '' "${start}d" "$ZSHRC"
}

# 清除所有脚本
clear() {
  start=$(_locate "$MARK_COMMENT")
  end=$(_locate "$MARK_END")

  sed -i '' "${start},${end}d" "$ZSHRC"
  # 删除方法开始的空白行
  sed -i '' "${start-1}d" "$ZSHRC"
}

job::build() {
  init
  cmd=${1}
  shift
  case $cmd in
  list) list "$@" ;;
  insert) insert "$@" ;;
  detail) detail "$@" ;;
  delete) delete "$@" ;;
  clear) clear "$@" ;;
  esac

  # shellcheck source=/dev/null
  source "$ZSHRC"
}

# cp ./zj.sh /usr/local/bin/zj
main() {
  job::build "$@"
}

main "$@"
