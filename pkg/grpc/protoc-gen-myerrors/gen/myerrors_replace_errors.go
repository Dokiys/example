// Code generated by protoc-gen-go-myerrors. DO NOT EDIT.
// source: myerrors.proto

package gen

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
	filepath "path/filepath"
	runtime "runtime"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1
const locKey = "location"

func IsInvalidParameter(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_InvalidParameter.String() && e.Code == 400
}

func IsAccessForbidden(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_AccessForbidden.String() && e.Code == 403
}

func IsUnauthenticated(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_Unauthenticated.String() && e.Code == 401
}

func IsBusinessError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_BusinessError.String() && e.Code == 400
}

func IsSystemError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_SystemError.String() && e.Code == 500
}

func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_NotFound.String() && e.Code == 400
}

func IsOrderNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_OrderNotFound.String() && e.Code == 400
}

func IsItemNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_ItemNotFound.String() && e.Code == 400
}

func ErrInvalidParameter(format string, args ...interface{}) *errors.Error {
	return errors.New(400, ErrorReason_InvalidParameter.String(), fmt.Sprintf(format, args...))
}

func ErrAccessForbidden(format string, args ...interface{}) *errors.Error {
	return errors.New(403, ErrorReason_AccessForbidden.String(), fmt.Sprintf(format, args...))
}

func ErrUnauthenticated(format string, args ...interface{}) *errors.Error {
	return errors.New(401, ErrorReason_Unauthenticated.String(), fmt.Sprintf(format, args...))
}

func ErrBusinessError(format string, args ...interface{}) *errors.Error {
	return errors.New(400, ErrorReason_BusinessError.String(), fmt.Sprintf(format, args...))
}

func ErrSystemError(format string, args ...interface{}) *errors.Error {
	return errors.New(500, ErrorReason_SystemError.String(), fmt.Sprintf(format, args...))
}

func ErrNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(400, ErrorReason_NotFound.String(), fmt.Sprintf(format, args...))
}

func ErrOrderNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(400, ErrorReason_OrderNotFound.String(), fmt.Sprintf(format, args...))
}

func ErrItemNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(400, ErrorReason_ItemNotFound.String(), fmt.Sprintf(format, args...))
}

func ErrInvalidParameterWithMeta(err error, msg string) *errors.Error {
	return ErrInvalidParameter(msg).WithMetadata(locationErrMeta(err))
}
func ErrAccessForbiddenWithMeta(err error, msg string) *errors.Error {
	return ErrAccessForbidden(msg).WithMetadata(locationErrMeta(err))
}
func ErrUnauthenticatedWithMeta(err error, msg string) *errors.Error {
	return ErrUnauthenticated(msg).WithMetadata(locationErrMeta(err))
}
func ErrBusinessErrorWithMeta(err error, msg string) *errors.Error {
	return ErrBusinessError(msg).WithMetadata(locationErrMeta(err))
}
func ErrSystemErrorWithMeta(err error, msg string) *errors.Error {
	return ErrSystemError(msg).WithMetadata(locationErrMeta(err))
}
func ErrNotFoundWithMeta(err error, msg string) *errors.Error {
	return ErrNotFound(msg).WithMetadata(locationErrMeta(err))
}
func ErrOrderNotFoundWithMeta(err error, msg string) *errors.Error {
	return ErrOrderNotFound(msg).WithMetadata(locationErrMeta(err))
}
func ErrItemNotFoundWithMeta(err error, msg string) *errors.Error {
	return ErrItemNotFound(msg).WithMetadata(locationErrMeta(err))
}

func TryErrInvalidParameterWrap(err error, msg string) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrInvalidParameter(msg).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = msg + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}

func TryErrInvalidParameterWrapf(err error, format string, args ...interface{}) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrInvalidParameter(format, args).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = fmt.Sprintf(format, args) + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}
func TryErrAccessForbiddenWrap(err error, msg string) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrAccessForbidden(msg).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = msg + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}

func TryErrAccessForbiddenWrapf(err error, format string, args ...interface{}) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrAccessForbidden(format, args).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = fmt.Sprintf(format, args) + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}
func TryErrUnauthenticatedWrap(err error, msg string) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrUnauthenticated(msg).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = msg + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}

func TryErrUnauthenticatedWrapf(err error, format string, args ...interface{}) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrUnauthenticated(format, args).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = fmt.Sprintf(format, args) + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}
func TryErrBusinessErrorWrap(err error, msg string) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrBusinessError(msg).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = msg + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}

func TryErrBusinessErrorWrapf(err error, format string, args ...interface{}) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrBusinessError(format, args).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = fmt.Sprintf(format, args) + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}
func TryErrSystemErrorWrap(err error, msg string) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrSystemError(msg).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = msg + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}

func TryErrSystemErrorWrapf(err error, format string, args ...interface{}) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrSystemError(format, args).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = fmt.Sprintf(format, args) + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}
func TryErrNotFoundWrap(err error, msg string) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrNotFound(msg).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = msg + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}

func TryErrNotFoundWrapf(err error, format string, args ...interface{}) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrNotFound(format, args).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = fmt.Sprintf(format, args) + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}
func TryErrOrderNotFoundWrap(err error, msg string) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrOrderNotFound(msg).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = msg + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}

func TryErrOrderNotFoundWrapf(err error, format string, args ...interface{}) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrOrderNotFound(format, args).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = fmt.Sprintf(format, args) + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}
func TryErrItemNotFoundWrap(err error, msg string) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrItemNotFound(msg).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = msg + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}

func TryErrItemNotFoundWrapf(err error, format string, args ...interface{}) *errors.Error {
	if e, ok := err.(*errors.Error); !ok {
		return ErrItemNotFound(format, args).WithMetadata(locationErrMeta(err))
	} else {
		e.Reason = fmt.Sprintf(format, args) + " " + e.Reason
		return e.WithMetadata(locationErrMeta(err))
	}
}

func locationErrMeta(err error) map[string]string {
	if err == nil {
		return map[string]string{locKey: location()}
	}

	if ee := new(errors.Error); errors.As(err, &ee) {
		m := ee.GetMetadata()
		var hasLocation bool
		for k, v := range m {
			if k == locKey && len(v) > 0 {
				hasLocation = true
				break
			}
		}

		if !hasLocation {
			m[locKey] = location()
		}
		return m
	}

	return map[string]string{locKey: location(), "error": err.Error()}
}

func location() string {
	pc := make([]uintptr, 6)
	n := runtime.Callers(1, pc)
	if n <= 1 {
		return ""
	}
	currentFuncPc := runtime.FuncForPC(pc[0])
	currentFile, _ := currentFuncPc.FileLine(pc[0])
	for i := 1; i < n; i++ {
		file, line := runtime.FuncForPC(pc[i]).FileLine(pc[i])

		if filepath.Dir(currentFile) == filepath.Dir(file) {
			continue
		}

		var split [2]int
		for i := 0; i < len(file) || i < len(currentFile); i++ {
			if file[i] == '/' {
				split[0], split[1] = i, split[0]
			}
			if file[i] != currentFile[i] {
				break
			}
		}

		if split[1]+1 > len(file) {
			return ""
		}
		return fmt.Sprintf(" %s:%d ", file[split[1]+1:], line)
	}

	return ""
}
